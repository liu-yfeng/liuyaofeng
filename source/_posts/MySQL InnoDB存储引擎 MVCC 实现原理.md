# MySQL InnoDB存储引擎 MVCC 实现原理

[TOC]


## 一、MVCC 简介
### 1.1、什么是 MVCC

MVCC 是 Multi Version Concurrency Control 的简称，代表多版本并发控制。

InnoDB 是一个多版本的存储引擎：它能够保存事务未提交前的数据，用于支持事务的并发操作和回滚。这些信息都被存储在系统表空间的回滚段中(rollback segment)。这个回滚段主要实现两个功能，一个是实现事务的回滚操作，另一个就是一致性非锁定读了。

### 1.2 MVCC 解决了什么问题

为什么需要 MVCC，还要从数据库事务的 ACID 特性说起。

ACID，它们分别代表了:

- Atomicity (原子性)
- Consistency (一致性)
- Isolation (隔离性)
- Durability (持久性)

原子性，表示一个事务的操作结果要么全部执行，要么全部不执行。

一致性，表示事务总是从一个一致的状态转换到另一个一致的状态。

隔离性，表示一个事务的修改结果在什么时间能够被其它事务看到，SQL1992 规范中，对隔离性定义了不同的隔离级别，分别为：

- 读未提交 (READ UNCOMMITED)，事务能够看到其它事务没有提交的修改，当另一个事务又回滚了修改后的情况又被称为**脏读 dirty read**。
- 读已提交 (READ COMMITED)，事务能够看到其它事务提交后的修改，这时会出现一个事务内两次读取数据可能因为其它事务提交的修改导致不一致的情况，称为**不可重复读**。
- 可重复读 (REPEATABLE READ)，在两次读取时读取到的数据的状态是一致的。
- 序列化 (SERIALIZABLE)，可重复读中可能出现第二次读读到第一次没有读到的数据，也就是被其它事务插入的数据，这种情况称为**幻读 phantom read**，序列化级别中不能出现幻读。

隔离级别依次增强，但是导致的问题是并发能力的减弱。

数据库通常使用锁来实现隔离性。最原生的锁，锁住一个资源后会禁止其它任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。所以就使用一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现，并发读还是不够，又提出了能不能让读写之间也不冲突的方法，就是读取数据时通过一个类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务 session 会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式实现这种功能。

### 1.3 MVCC 实现

MVCC 是通过保存数据在某个时间点的快照来实现的，不同存储引擎的 MVCC 实现是不同的，典型的有乐观并发控制和悲观并发控制。

## MVCC 具体实现

在内部实现中，InnoDB 通过在每一行记录上添加了三个隐藏列实现。其中一个 6 字节(byte) 的 `DB_TRX_ID` 作为事务 ID 标识，用来标记最近一个事务在该行上的 insert 或者 update 的情况。`DB_TRX_ID` 中还有一个删除标识位，用来显示该行是否被删除(也就是逻辑删除的概念，InnoDB 并不会真正去物理删除某条记录)。另外，每一行还有一个 7 字节(byte) 的 `DB_ROLL_PTR` 列，可称之为回滚指针。这个回滚指针指向了写到 rollback segment 中的 undo log 的一条记录。如果该数据行被修改，那么这个 undo log 里的该条记录会在行记录被修改前重建，即保存的将是数据修改前的记录。另外行数据 insert 时，还会产生一个 6 字节(byte) 的单调自增的 `DB_ROW_ID` 列。如果 InnoDB 自动地产生聚集索引的话(也就是没有显示指定 PRIMARY KEY)，这个自动产生的聚集索引值就是 `DB_ROW_ID` 的内容，否则的话 `DB_ROW_ID	` 值无意义。

回滚段中的 undo log 可以分为 insert undo log 和 update undo log 两种，它们在存储上实际是分离开的。insert undo log 一般只用于事务回滚，只要事务一提交后可以立马删除。update undo log 除了事务的回滚外，还用于非锁定读。当 InnoDB 分配了一个一致性的快照读时，它就需要 update undo log 里面的信息来建立一个较早的行版本，所以只有当前没有任何事务需要对该行记录进行快照读时，它才可以删除，而不是事务一提交就删除(因为可能事务提交了，但当前的其它 session 的快照读还没执行完)

InnoDB 的 MVCC，是通过在每行记面保存三个隐藏的列来实现的，这三个列为：

- DB_TRX_ID: 一个 6byte 的标识，每处理一个事务，其值自动 +1，“创建时间”和“删除时间”记录的就是这个 DB_TRX_ID 的值，如 insert、update、delete 操作时，删除操作用 1 bit 表示。DB_TRX_ID 是最重要的一个，可以通过语句 `SHOW ENGINE INNODB STATUS\G` 来查找。
- DB_ROLL_PTR: 大小是 7 byte，指向写到 rollback segment (回滚段)的一条 undo log 记录(update 操作的话，记录 update 前的 ROW 值)
- DB_ROW_ID: 大小是 6 byte，该值随新行插入单调增加，当由 Innodb 自动产生聚集索引时，聚集索引包括这个 DB_ROW_ID 的值，不然的话聚集索引中不包括这个值，这个用于索引当中。

## Guidelines for Managing  Rollback Segments

1. 正常地去提交事务，包括非锁定的一致性读。因为 InnoDB 无法及时删除 update undo log，将会导致回滚段越来越大，甚至占据绝大部分系统表空间。
2. 合理分配好 rollback segment 大小。比较典型的，undo log 占据的物理空间应该小于当前数量相当的 insert 或者 update 的行数量所需要的空间。
3. InnoDB 中，当你执行一条 delete 语句后，行记录并不会立马被物理删除。InnoDB 只有在它删除了对应的 update undo log 之后，它才会实际去物理删除该行记录和它的索引记录，这被称之为 purge，不过 purge 通常很快，速度相当于 delete sql 执行的时间。
4. 如果频繁地在一个表的某一块区间以相同的速率 insert 和 delete，会引起 purge 线程落后，从而导致数据库达到磁盘瓶颈，这时就可以通过调整 `innodb_max_purge_lag` 这个系统参数来缓解。

